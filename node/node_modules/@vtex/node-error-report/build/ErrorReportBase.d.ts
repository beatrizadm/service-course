import { ParsedInfo } from './errorParsing';
export interface AlreadyParsedError extends Error {
    errorReportMetadata: {
        errorId: string;
        reportCount: number;
    };
}
interface Config {
    maxSerializationDepth: number;
    maxStringLength: number;
}
interface Metadata {
    timestamp: string;
    errorId: string;
    reportCount: number;
    metrics: {
        instantiationTime: string;
    };
}
export interface ErrorReportBaseConstructorArgs {
    kind: string;
    originalError: Error;
    config: Config;
    message?: string;
    details?: Record<string, any>;
}
export interface ErrorReportSerializableObj {
    kind: string;
    details?: Record<string, any>;
    message: string;
    metadata: Metadata;
    stack?: string;
    parsedInfo?: Record<string, any>;
    code?: string;
}
export declare class ErrorReportBase extends Error {
    static MAX_ERROR_STRING_LENGTH: number;
    static MAX_SERIALIZATION_DEPTH: number;
    static isAlreadyParsedError(err: any): err is AlreadyParsedError;
    readonly config: Config;
    readonly metadata: Metadata;
    readonly kind: string;
    readonly originalError: AlreadyParsedError;
    readonly details?: Record<string, any>;
    readonly parsedInfo: ParsedInfo;
    constructor(args: ErrorReportBaseConstructorArgs);
    markErrorAsReported(): void;
    isErrorReported(): boolean;
    toObject(): ErrorReportSerializableObj;
    protected cloneAndSanitize(obj: any): any;
}
export {};
